<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ponteiros e sua Importância em Go</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: #0a0a0a;
            color: #e4e4e7;
            line-height: 1.7;
            padding: 20px;
        }
        
        .container {
            max-width: 1100px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            padding: 60px 20px 40px;
            background: linear-gradient(135deg, rgba(255,255,255,0.03) 0%, rgba(255,255,255,0.01) 100%);
            border-radius: 20px;
            margin-bottom: 50px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        h1 {
            font-size: clamp(2rem, 5vw, 3.5rem);
            font-weight: 700;
            background: linear-gradient(135deg, #ffffff 0%, #a0a0a0 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 15px;
            letter-spacing: -1px;
        }
        
        .subtitle {
            font-size: 1.1rem;
            color: #888;
            font-weight: 300;
        }
        
        .nav-links {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 30px;
        }
        
        .nav-link {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 10px 20px;
            border-radius: 8px;
            color: #ccc;
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }
        
        .nav-link:hover {
            background: rgba(255,255,255,0.08);
            border-color: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }
        
        .section {
            background: rgba(255,255,255,0.02);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 16px;
            padding: 40px;
            margin-bottom: 40px;
            transition: all 0.3s ease;
        }
        
        .section:hover {
            border-color: rgba(255,255,255,0.15);
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        
        h2 {
            font-size: 2rem;
            color: #fff;
            margin-bottom: 25px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        h2::before {
            content: '';
            width: 5px;
            height: 32px;
            background: linear-gradient(180deg, #666 0%, #999 100%);
            border-radius: 3px;
        }
        
        h3 {
            font-size: 1.4rem;
            color: #ddd;
            margin-top: 30px;
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        p {
            color: #b0b0b0;
            margin-bottom: 20px;
            font-size: 1.05rem;
        }
        
        .code-block {
            background: #0d0d0d;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
            position: relative;
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .code-title {
            color: #888;
            font-size: 0.85rem;
            font-family: 'JetBrains Mono', monospace;
        }
        
        code {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.95rem;
            line-height: 1.6;
            color: #e4e4e7;
        }
        
        pre {
            margin: 0;
        }
        
        .keyword {
            color: #f472b6;
        }
        
        .function {
            color: #a78bfa;
        }
        
        .string {
            color: #34d399;
        }
        
        .comment {
            color: #6b7280;
            font-style: italic;
        }
        
        .number {
            color: #60a5fa;
        }
        
        .type {
            color: #fbbf24;
        }
        
        .highlight-box {
            background: rgba(255,255,255,0.03);
            border-left: 4px solid #666;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        .highlight-box.warning {
            border-left-color: #fbbf24;
            background: rgba(251, 191, 36, 0.05);
        }
        
        .highlight-box.info {
            border-left-color: #60a5fa;
            background: rgba(96, 165, 250, 0.05);
        }
        
        .highlight-box.success {
            border-left-color: #34d399;
            background: rgba(52, 211, 153, 0.05);
        }
        
        .highlight-box.danger {
            border-left-color: #ef4444;
            background: rgba(239, 68, 68, 0.05);
        }
        
        .list {
            list-style: none;
            margin: 20px 0;
        }
        
        .list li {
            padding: 12px 0;
            padding-left: 30px;
            position: relative;
            color: #b0b0b0;
        }
        
        .list li::before {
            content: '▹';
            position: absolute;
            left: 0;
            color: #666;
            font-size: 1.3rem;
            font-weight: bold;
        }
        
        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }
        
        .comparison-card {
            background: rgba(255,255,255,0.02);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 12px;
            padding: 25px;
            transition: all 0.3s ease;
        }
        
        .comparison-card:hover {
            border-color: rgba(255,255,255,0.15);
            transform: translateY(-2px);
        }
        
        .comparison-card h4 {
            color: #fff;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }
        
        .visual-diagram {
            background: rgba(255,255,255,0.02);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 30px;
            margin: 25px 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
        }
        
        .memory-block {
            display: inline-block;
            background: rgba(96, 165, 250, 0.15);
            border: 2px solid rgba(96, 165, 250, 0.4);
            padding: 15px 20px;
            border-radius: 8px;
            margin: 10px;
            text-align: center;
        }
        
        .pointer-arrow {
            display: inline-block;
            color: #34d399;
            font-size: 2rem;
            margin: 0 15px;
        }
        
        footer {
            text-align: center;
            padding: 40px 20px;
            color: #666;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .section {
                padding: 25px;
            }
            
            h2 {
                font-size: 1.6rem;
            }
            
            .code-block {
                padding: 15px;
            }
            
            .comparison-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Ponteiros em Go</h1>
            <p class="subtitle">Entendendo Endereços de Memória e Referências</p>
            <div class="nav-links">
                <a href="#conceito" class="nav-link">O que são</a>
                <a href="#operadores" class="nav-link">Operadores</a>
                <a href="#funcoes" class="nav-link">Ponteiros em Funções</a>
                <a href="#structs" class="nav-link">Ponteiros e Structs</a>
                <a href="#pratico" class="nav-link">Exemplos Práticos</a>
            </div>
        </header>
        
        <section id="conceito" class="section">
            <h2>O que são Ponteiros?</h2>
            
            <p>Um ponteiro é uma variável que armazena o <strong>endereço de memória</strong> de outra variável. Em vez de guardar um valor diretamente, ele guarda a localização onde esse valor está armazenado.</p>
            
            <div class="visual-diagram">
                <p style="margin-bottom: 20px; color: #ccc;">Representação Visual:</p>
                <div style="display: flex; align-items: center; flex-wrap: wrap;">
                    <div class="memory-block">
                        <div style="color: #888;">Variável: x</div>
                        <div style="font-size: 1.5rem; color: #60a5fa; margin-top: 5px;">42</div>
                        <div style="color: #888; font-size: 0.8rem; margin-top: 5px;">Endereço: 0x1040</div>
                    </div>
                    <span class="pointer-arrow">→</span>
                    <div class="memory-block">
                        <div style="color: #888;">Ponteiro: p</div>
                        <div style="font-size: 1.2rem; color: #34d399; margin-top: 5px;">0x1040</div>
                        <div style="color: #888; font-size: 0.8rem; margin-top: 5px;">Aponta para x</div>
                    </div>
                </div>
            </div>
            
            <h3>Por que Ponteiros são Importantes?</h3>
            
            <div class="comparison-grid">
                <div class="comparison-card">
                    <h4>1. Eficiência</h4>
                    <p>Passar um ponteiro é mais rápido do que copiar uma struct grande inteira. Apenas 8 bytes (endereço) são copiados, não todo o conteúdo.</p>
                </div>
                
                <div class="comparison-card">
                    <h4>2. Modificação</h4>
                    <p>Permite modificar variáveis fora do escopo da função. Sem ponteiros, funções trabalham com cópias.</p>
                </div>
                
                <div class="comparison-card">
                    <h4>3. Compartilhamento</h4>
                    <p>Múltiplas partes do código podem referenciar e modificar os mesmos dados.</p>
                </div>
                
                <div class="comparison-card">
                    <h4>4. Estruturas Dinâmicas</h4>
                    <p>Essencial para criar estruturas de dados como listas encadeadas, árvores, grafos.</p>
                </div>
            </div>
            
            <div class="highlight-box info">
                <strong>Curiosidade:</strong> Go gerencia memória automaticamente com garbage collection. Você não precisa se preocupar em liberar memória manualmente como em C/C++.
            </div>
        </section>
        
        <section id="operadores" class="section">
            <h2>Operadores de Ponteiro</h2>
            
            <p>Go usa dois operadores principais para trabalhar com ponteiros:</p>
            
            <h3>Operador & (Address-of)</h3>
            <p>Retorna o <strong>endereço de memória</strong> de uma variável.</p>
            
            <div class="code-block">
                <div class="code-header">
                    <span class="code-title">operador_address.go</span>
                </div>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="keyword">func</span> <span class="function">main</span>() {
    x := <span class="number">42</span>
    
    <span class="comment">// & retorna o endereço de memória</span>
    p := &x
    
    fmt.<span class="function">Println</span>(<span class="string">"Valor de x:"</span>, x)           <span class="comment">// 42</span>
    fmt.<span class="function">Println</span>(<span class="string">"Endereço de x:"</span>, &x)       <span class="comment">// 0xc000012028 (exemplo)</span>
    fmt.<span class="function">Println</span>(<span class="string">"Valor de p:"</span>, p)           <span class="comment">// 0xc000012028 (mesmo endereço)</span>
    fmt.<span class="function">Printf</span>(<span class="string">"Tipo de p: %T\n"</span>, p)       <span class="comment">// *int (ponteiro para int)</span>
}</code></pre>
            </div>
            
            <h3>Operador * (Dereference)</h3>
            <p>Acessa o <strong>valor</strong> armazenado no endereço do ponteiro.</p>
            
            <div class="code-block">
                <div class="code-header">
                    <span class="code-title">operador_dereference.go</span>
                </div>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="keyword">func</span> <span class="function">main</span>() {
    x := <span class="number">42</span>
    p := &x
    
    <span class="comment">// * acessa o valor no endereço</span>
    fmt.<span class="function">Println</span>(<span class="string">"Valor apontado por p:"</span>, *p)  <span class="comment">// 42</span>
    
    <span class="comment">// Modificando através do ponteiro</span>
    *p = <span class="number">100</span>
    
    fmt.<span class="function">Println</span>(<span class="string">"Novo valor de x:"</span>, x)        <span class="comment">// 100</span>
    fmt.<span class="function">Println</span>(<span class="string">"Valor através de p:"</span>, *p)    <span class="comment">// 100</span>
}</code></pre>
            </div>
            
            <h3>Declaração de Tipos Ponteiro</h3>
            
            <div class="code-block">
                <div class="code-header">
                    <span class="code-title">declaracao_ponteiros.go</span>
                </div>
                <pre><code><span class="keyword">func</span> <span class="function">main</span>() {
    <span class="comment">// Diferentes formas de declarar ponteiros</span>
    
    <span class="comment">// 1. Declaração com inferência</span>
    x := <span class="number">10</span>
    p1 := &x
    
    <span class="comment">// 2. Declaração explícita</span>
    <span class="keyword">var</span> p2 *<span class="type">int</span> = &x
    
    <span class="comment">// 3. Ponteiro nulo (zero value)</span>
    <span class="keyword">var</span> p3 *<span class="type">int</span>
    fmt.<span class="function">Println</span>(p3 == <span class="keyword">nil</span>)  <span class="comment">// true</span>
    
    <span class="comment">// 4. Usando new (aloca memória)</span>
    p4 := <span class="function">new</span>(<span class="type">int</span>)
    *p4 = <span class="number">20</span>
    
    <span class="comment">// 5. Ponteiro para diferentes tipos</span>
    s := <span class="string">"Hello"</span>
    ps := &s
    
    f := <span class="number">3.14</span>
    pf := &f
    
    fmt.<span class="function">Printf</span>(<span class="string">"p1: %T, p2: %T, p3: %T\n"</span>, p1, p2, p3)
    fmt.<span class="function">Printf</span>(<span class="string">"p4: %T, ps: %T, pf: %T\n"</span>, p4, ps, pf)
}</code></pre>
            </div>
            
            <div class="highlight-box warning">
                <strong>Cuidado:</strong> Nunca tente desreferenciar um ponteiro nil! Isso causa panic (runtime error).
            </div>
            
            <div class="code-block">
                <div class="code-header">
                    <span class="code-title">nil_pointer.go</span>
                </div>
                <pre><code><span class="keyword">func</span> <span class="function">main</span>() {
    <span class="keyword">var</span> p *<span class="type">int</span>
    
    <span class="comment">// ERRADO - panic: nil pointer dereference</span>
    <span class="comment">// fmt.Println(*p)</span>
    
    <span class="comment">// CORRETO - sempre verifique antes</span>
    <span class="keyword">if</span> p != <span class="keyword">nil</span> {
        fmt.<span class="function">Println</span>(*p)
    } <span class="keyword">else</span> {
        fmt.<span class="function">Println</span>(<span class="string">"Ponteiro é nil"</span>)
    }
}</code></pre>
            </div>
        </section>
        
        <section id="funcoes" class="section">
            <h2>Ponteiros em Funções</h2>
            
            <p>Ponteiros são fundamentais para modificar valores passados para funções.</p>
            
            <h3>Passagem por Valor vs Passagem por Referência</h3>
            
            <div class="code-block">
                <div class="code-header">
                    <span class="code-title">valor_vs_referencia.go</span>
                </div>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="comment">// Passagem por VALOR - não modifica o original</span>
<span class="keyword">func</span> <span class="function">incrementarValor</span>(x <span class="type">int</span>) {
    x++
    fmt.<span class="function">Println</span>(<span class="string">"Dentro da função:"</span>, x)
}

<span class="comment">// Passagem por REFERÊNCIA - modifica o original</span>
<span class="keyword">func</span> <span class="function">incrementarPonteiro</span>(x *<span class="type">int</span>) {
    *x++
    fmt.<span class="function">Println</span>(<span class="string">"Dentro da função:"</span>, *x)
}

<span class="keyword">func</span> <span class="function">main</span>() {
    num := <span class="number">10</span>
    
    fmt.<span class="function">Println</span>(<span class="string">"=== Passagem por Valor ==="</span>)
    fmt.<span class="function">Println</span>(<span class="string">"Antes:"</span>, num)
    <span class="function">incrementarValor</span>(num)
    fmt.<span class="function">Println</span>(<span class="string">"Depois:"</span>, num)  <span class="comment">// 10 (não mudou!)</span>
    
    fmt.<span class="function">Println</span>(<span class="string">"\n=== Passagem por Referência ==="</span>)
    fmt.<span class="function">Println</span>(<span class="string">"Antes:"</span>, num)
    <span class="function">incrementarPonteiro</span>(&num)
    fmt.<span class="function">Println</span>(<span class="string">"Depois:"</span>, num)  <span class="comment">// 11 (modificado!)</span>
}</code></pre>
            </div>
            
            <h3>Retornando Ponteiros</h3>
            
            <div class="code-block">
                <div class="code-header">
                    <span class="code-title">retornar_ponteiros.go</span>
                </div>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="comment">// Função que retorna ponteiro</span>
<span class="keyword">func</span> <span class="function">criarNumero</span>(valor <span class="type">int</span>) *<span class="type">int</span> {
    num := valor
    <span class="keyword">return</span> &num  <span class="comment">// Go permite retornar endereço de variável local</span>
}

<span class="comment">// Função que cria e inicializa</span>
<span class="keyword">func</span> <span class="function">novoInt</span>(valor <span class="type">int</span>) *<span class="type">int</span> {
    p := <span class="function">new</span>(<span class="type">int</span>)
    *p = valor
    <span class="keyword">return</span> p
}

<span class="keyword">func</span> <span class="function">main</span>() {
    p1 := <span class="function">criarNumero</span>(<span class="number">42</span>)
    p2 := <span class="function">novoInt</span>(<span class="number">100</span>)
    
    fmt.<span class="function">Println</span>(*p1)  <span class="comment">// 42</span>
    fmt.<span class="function">Println</span>(*p2)  <span class="comment">// 100</span>
    
    *p1 = <span class="number">50</span>
    *p2 = <span class="number">200</span>
    
    fmt.<span class="function">Println</span>(*p1)  <span class="comment">// 50</span>
    fmt.<span class="function">Println</span>(*p2)  <span class="comment">// 200</span>
}</code></pre>
            </div>
            
            <div class="highlight-box info">
                <strong>Nota:</strong> Diferente de C, em Go é seguro retornar o endereço de uma variável local. O compilador automaticamente aloca na heap se necessário.
            </div>
            
            <h3>Múltiplos Retornos com Ponteiros</h3>
            
            <div class="code-block">
                <div class="code-header">
                    <span class="code-title">multiplos_retornos.go</span>
                </div>
                <pre><code><span class="keyword">func</span> <span class="function">trocar</span>(a, b *<span class="type">int</span>) {
    *a, *b = *b, *a
}

<span class="keyword">func</span> <span class="function">dividir</span>(a, b <span class="type">int</span>) (*<span class="type">int</span>, <span class="type">error</span>) {
    <span class="keyword">if</span> b == <span class="number">0</span> {
        <span class="keyword">return</span> <span class="keyword">nil</span>, fmt.<span class="function">Errorf</span>(<span class="string">"divisão por zero"</span>)
    }
    resultado := a / b
    <span class="keyword">return</span> &resultado, <span class="keyword">nil</span>
}

<span class="keyword">func</span> <span class="function">main</span>() {
    x, y := <span class="number">10</span>, <span class="number">20</span>
    fmt.<span class="function">Printf</span>(<span class="string">"Antes: x=%d, y=%d\n"</span>, x, y)
    
    <span class="function">trocar</span>(&x, &y)
    fmt.<span class="function">Printf</span>(<span class="string">"Depois: x=%d, y=%d\n"</span>, x, y)
    
    resultado, err := <span class="function">dividir</span>(<span class="number">20</span>, <span class="number">4</span>)
    <span class="keyword">if</span> err != <span class="keyword">nil</span> {
        fmt.<span class="function">Println</span>(<span class="string">"Erro:"</span>, err)
    } <span class="keyword">else</span> {
        fmt.<span class="function">Println</span>(<span class="string">"Resultado:"</span>, *resultado)
    }
}</code></pre>
            </div>
        </section>
        
        <section id="structs" class="section">
            <h2>Ponteiros e Structs</h2>
            
            <p>Ponteiros são especialmente úteis com structs para evitar cópias desnecessárias e permitir modificações.</p>
            
            <h3>Acesso a Campos</h3>
            
            <div class="code-block">
                <div class="code-header">
                    <span class="code-title">ponteiros_structs.go</span>
                </div>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="keyword">type</span> Pessoa <span class="keyword">struct</span> {
    Nome  <span class="type">string</span>
    Idade <span class="type">int</span>
}

<span class="keyword">func</span> <span class="function">main</span>() {
    p1 := Pessoa{<span class="string">"João"</span>, <span class="number">25</span>}
    
    <span class="comment">// Ponteiro para struct</span>
    pp := &p1
    
    <span class="comment">// Go permite acessar campos diretamente</span>
    <span class="comment">// Não precisa escrever (*pp).Nome</span>
    fmt.<span class="function">Println</span>(pp.Nome)   <span class="comment">// João (sintaxe simplificada)</span>
    fmt.<span class="function">Println</span>(pp.Idade)  <span class="comment">// 25</span>
    
    <span class="comment">// Modificando através do ponteiro</span>
    pp.Nome = <span class="string">"Maria"</span>
    pp.Idade = <span class="number">30</span>
    
    fmt.<span class="function">Printf</span>(<span class="string">"%+v\n"</span>, p1)  <span class="comment">// {Nome:Maria Idade:30}</span>
    
    <span class="comment">// Criando ponteiro diretamente</span>
    p2 := &Pessoa{<span class="string">"Pedro"</span>, <span class="number">28</span>}
    fmt.<span class="function">Printf</span>(<span class="string">"%+v\n"</span>, p2)
}</code></pre>
            </div>
            
            <h3>Modificando Structs em Funções</h3>
            
            <div class="code-block">
                <div class="code-header">
                    <span class="code-title">modificar_structs.go</span>
                </div>
                <pre><code><span class="keyword">type</span> Conta <span class="keyword">struct</span> {
    Titular <span class="type">string</span>
    Saldo   <span class="type">float64</span>
}

<span class="comment">// SEM ponteiro - não modifica o original</span>
<span class="keyword">func</span> <span class="function">depositarErrado</span>(c Conta, valor <span class="type">float64</span>) {
    c.Saldo += valor  <span class="comment">// Modifica apenas a cópia</span>
}

<span class="comment">// COM ponteiro - modifica o original</span>
<span class="keyword">func</span> <span class="function">depositar</span>(c *Conta, valor <span class="type">float64</span>) {
    c.Saldo += valor  <span class="comment">// Modifica o original</span>
}

<span class="comment">// Retorna nova struct</span>
<span class="keyword">func</span> <span class="function">novaConta</span>(titular <span class="type">string</span>, saldo <span class="type">float64</span>) *Conta {
    <span class="keyword">return</span> &Conta{
        Titular: titular,
        Saldo:   saldo,
    }
}

<span class="keyword">func</span> <span class="function">main</span>() {
    conta := Conta{<span class="string">"João"</span>, <span class="number">1000.00</span>}
    
    <span class="function">depositarErrado</span>(conta, <span class="number">500</span>)
    fmt.<span class="function">Println</span>(conta.Saldo)  <span class="comment">// 1000.00 (não mudou)</span>
    
    <span class="function">depositar</span>(&conta, <span class="number">500</span>)
    fmt.<span class="function">Println</span>(conta.Saldo)  <span class="comment">// 1500.00 (modificado)</span>
    
    c2 := <span class="function">novaConta</span>(<span class="string">"Maria"</span>, <span class="number">2000</span>)
    <span class="function">depositar</span>(c2, <span class="number">300</span>)
    fmt.<span class="function">Println</span>(c2.Saldo)  <span class="comment">// 2300.00</span>
}</code></pre>
            </div>
            
            <h3>Performance: Valor vs Ponteiro</h3>
            
            <div class="code-block">
                <div class="code-header">
                    <span class="code-title">performance.go</span>
                </div>
                <pre><code><span class="keyword">type</span> StructPequena <span class="keyword">struct</span> {
    ID <span class="type">int</span>
}

<span class="keyword">type</span> StructGrande <span class="keyword">struct</span> {
    Dados [<span class="number">1000</span>]<span class="type">int</span>
    Info  [<span class="number">100</span>]<span class="type">string</span>
}

<span class="comment">// Para structs pequenas, valor é OK</span>
<span class="keyword">func</span> <span class="function">processarPequena</span>(s StructPequena) {
    <span class="comment">// Cópia é rápida e barata</span>
}

<span class="comment">// Para structs grandes, use ponteiro</span>
<span class="keyword">func</span> <span class="function">processarGrande</span>(s *StructGrande) {
    <span class="comment">// Evita copiar milhares de bytes</span>
}

<span class="keyword">func</span> <span class="function">main</span>() {
    pequena := StructPequena{ID: <span class="number">1</span>}
    grande := StructGrande{}
    
    <span class="function">processarPequena</span>(pequena)  <span class="comment">// OK passar por valor</span>
    <span class="function">processarGrande</span>(&grande)    <span class="comment">// Use ponteiro</span>
}</code></pre>
            </div>
            
            <div class="highlight-box warning">
                <strong>Regra de Ouro:</strong> Use ponteiros para structs quando precisar modificá-las OU quando forem grandes (mais de ~100 bytes). Para structs pequenas imutáveis, passar por valor é mais simples e seguro.
            </div>
        </section>
        
        <section id="pratico" class="section">
            <h2>Exemplos Práticos Completos</h2>
            
            <h3>1. Lista Encadeada (Linked List)</h3>
            
            <div class="code-block">
                <div class="code-header">
                    <span class="code-title">linked_list.go</span>
                </div>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="keyword">type</span> Node <span class="keyword">struct</span> {
    Valor <span class="type">int</span>
    Proximo *Node  <span class="comment">// Ponteiro para o próximo nó</span>
}

<span class="keyword">type</span> LinkedList <span class="keyword">struct</span> {
    Head *Node
}

<span class="keyword">func</span> (l *LinkedList) <span class="function">Adicionar</span>(valor <span class="type">int</span>) {
    novoNode := &Node{Valor: valor}
    
    <span class="keyword">if</span> l.Head == <span class="keyword">nil</span> {
        l.Head = novoNode
        <span class="keyword">return</span>
    }
    
    <span class="comment">// Percorre até o último nó</span>
    atual := l.Head
    <span class="keyword">for</span> atual.Proximo != <span class="keyword">nil</span> {
        atual = atual.Proximo
    }
    atual.Proximo = novoNode
}

<span class="keyword">func</span> (l *LinkedList) <span class="function">Exibir</span>() {
    atual := l.Head
    <span class="keyword">for</span> atual != <span class="keyword">nil</span> {
        fmt.<span class="function">Printf</span>(<span class="string">"%d -> "</span>, atual.Valor)
        atual = atual.Proximo
    }
    fmt.<span class="function">Println</span>(<span class="string">"nil"</span>)
}

<span class="keyword">func</span> (l *LinkedList) <span class="function">Buscar</span>(valor <span class="type">int</span>) *Node {
    atual := l.Head
    <span class="keyword">for</span> atual != <span class="keyword">nil</span> {
        <span class="keyword">if</span> atual.Valor == valor {
            <span class="keyword">return</span> atual
        }
        atual = atual.Proximo
    }
    <span class="keyword">return</span> <span class="keyword">nil</span>
}

<span class="keyword">func</span> <span class="function">main</span>() {
    lista := &LinkedList{}
    
    lista.<span class="function">Adicionar</span>(<span class="number">10</span>)
    lista.<span class="function">Adicionar</span>(<span class="number">20</span>)
    lista.<span class="function">Adicionar</span>(<span class="number">30</span>)
    
    lista.<span class="function">Exibir</span>()
    
    node := lista.<span class="function">Buscar</span>(<span class="number">20</span>)
    <span class="keyword">if</span> node != <span class="keyword">nil</span> {
        fmt.<span class="function">Printf</span>(<span class="string">"Encontrado: %d\n"</span>, node.Valor)
    }
}</code></pre>
            </div>
            
            <h3>2. Cache Simples</h3>
            
            <div class="code-block">
                <div class="code-header">
                    <span class="code-title">cache.go</span>
                </div>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"time"</span>
)

<span class="keyword">type</span> CacheItem <span class="keyword">struct</span> {
    Valor      <span class="keyword">interface</span>{}
    Expiracao  time.Time
}

<span class="keyword">type</span> Cache <span class="keyword">struct</span> {
    items <span class="keyword">map</span>[<span class="type">string</span>]*CacheItem
}

<span class="keyword">func</span> <span class="function">NovoCache</span>() *Cache {
    <span class="keyword">return</span> &Cache{
        items: <span class="function">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*CacheItem),
    }
}

<span class="keyword">func</span> (c *Cache) <span class="function">Set</span>(chave <span class="type">string</span>, valor <span class="keyword">interface</span>{}, duracao time.Duration) {
    expiracao := time.<span class="function">Now</span>().<span class="function">Add</span>(duracao)
    c.items[chave] = &CacheItem{
        Valor:     valor,
        Expiracao: expiracao,
    }
}

<span class="keyword">func</span> (c *Cache) <span class="function">Get</span>(chave <span class="type">string</span>) (<span class="keyword">interface</span>{}, <span class="type">bool</span>) {
    item, existe := c.items[chave]
    
    <span class="keyword">if</span> !existe {
        <span class="keyword">return</span> <span class="keyword">nil</span>, <span class="keyword">false</span>
    }
    
    <span class="comment">// Verifica se expirou</span>
    <span class="keyword">if</span> time.<span class="function">Now</span>().<span class="function">After</span>(item.Expiracao) {
        <span class="function">delete</span>(c.items, chave)
        <span class="keyword">return</span> <span class="keyword">nil</span>, <span class="keyword">false</span>
    }
    
    <span class="keyword">return</span> item.Valor, <span class="keyword">true</span>
}

<span class="keyword">func</span> (c *Cache) <span class="function">Delete</span>(chave <span class="type">string</span>) {
    <span class="function">delete</span>(c.items, chave)
}

<span class="keyword">func</span> <span class="function">main</span>() {
    cache := <span class="function">NovoCache</span>()
    
    <span class="comment">// Adiciona itens</span>
    cache.<span class="function">Set</span>(<span class="string">"usuario:1"</span>, <span class="string">"João Silva"</span>, <span class="number">5</span>*time.Second)
    cache.<span class="function">Set</span>(<span class="string">"usuario:2"</span>, <span class="string">"Maria Santos"</span>, <span class="number">10</span>*time.Second)
    
    <span class="comment">// Recupera imediatamente</span>
    <span class="keyword">if</span> valor, ok := cache.<span class="function">Get</span>(<span class="string">"usuario:1"</span>); ok {
        fmt.<span class="function">Println</span>(<span class="string">"Encontrado:"</span>, valor)
    }
    
    <span class="comment">// Aguarda expiração</span>
    time.<span class="function">Sleep</span>(<span class="number">6</span> * time.Second)
    
    <span class="keyword">if</span> _, ok := cache.<span class="function">Get</span>(<span class="string">"usuario:1"</span>); !ok {
        fmt.<span class="function">Println</span>(<span class="string">"Item expirou"</span>)
    }
    
    <span class="keyword">if</span> valor, ok := cache.<span class="function">Get</span>(<span class="string">"usuario:2"</span>); ok {
        fmt.<span class="function">Println</span>(<span class="string">"Ainda válido:"</span>, valor)
    }
}</code></pre>
            </div>
            
            <h3>3. Builder Pattern</h3>
            
            <div class="code-block">
                <div class="code-header">
                    <span class="code-title">builder.go</span>
                </div>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="keyword">type</span> Carro <span class="keyword">struct</span> {
    Marca     <span class="type">string</span>
    Modelo    <span class="type">string</span>
    Ano       <span class="type">int</span>
    Cor       <span class="type">string</span>
    Portas    <span class="type">int</span>
    Automatico <span class="type">bool</span>
}

<span class="keyword">type</span> CarroBuilder <span class="keyword">struct</span> {
    carro *Carro
}

<span class="keyword">func</span> <span class="function">NovoCarro</span>() *CarroBuilder {
    <span class="keyword">return</span> &CarroBuilder{
        carro: &Carro{},
    }
}

<span class="keyword">func</span> (b *CarroBuilder) <span class="function">Marca</span>(marca <span class="type">string</span>) *CarroBuilder {
    b.carro.Marca = marca
    <span class="keyword">return</span> b
}

<span class="keyword">func</span> (b *CarroBuilder) <span class="function">Modelo</span>(modelo <span class="type">string</span>) *CarroBuilder {
    b.carro.Modelo = modelo
    <span class="keyword">return</span> b
}

<span class="keyword">func</span> (b *CarroBuilder) <span class="function">Ano</span>(ano <span class="type">int</span>) *CarroBuilder {
    b.carro.Ano = ano
    <span class="keyword">return</span> b
}

<span class="keyword">func</span> (b *CarroBuilder) <span class="function">Cor</span>(cor <span class="type">string</span>) *CarroBuilder {
    b.carro.Cor = cor
    <span class="keyword">return</span> b
}

<span class="keyword">func</span> (b *CarroBuilder) <span class="function">Portas</span>(portas <span class="type">int</span>) *CarroBuilder {
    b.carro.Portas = portas
    <span class="keyword">return</span> b
}

<span class="keyword">func</span> (b *CarroBuilder) <span class="function">Automatico</span>(auto <span class="type">bool</span>) *CarroBuilder {
    b.carro.Automatico = auto
    <span class="keyword">return</span> b
}

<span class="keyword">func</span> (b *CarroBuilder) <span class="function">Build</span>() *Carro {
    <span class="keyword">return</span> b.carro
}

<span class="keyword">func</span> <span class="function">main</span>() {
    <span class="comment">// Construção fluente com method chaining</span>
    carro := <span class="function">NovoCarro</span>().
        <span class="function">Marca</span>(<span class="string">"Toyota"</span>).
        <span class="function">Modelo</span>(<span class="string">"Corolla"</span>).
        <span class="function">Ano</span>(<span class="number">2024</span>).
        <span class="function">Cor</span>(<span class="string">"Prata"</span>).
        <span class="function">Portas</span>(<span class="number">4</span>).
        <span class="function">Automatico</span>(<span class="keyword">true</span>).
        <span class="function">Build</span>()
    
    fmt.<span class="function">Printf</span>(<span class="string">"%+v\n"</span>, carro)
}</code></pre>
            </div>
            
            <h3>4. Modificação de Slices</h3>
            
            <div class="code-block">
                <div class="code-header">
                    <span class="code-title">ponteiros_slices.go</span>
                </div>
                <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="comment">// Modifica elementos, mas não pode redimensionar</span>
<span class="keyword">func</span> <span class="function">modificarElementos</span>(numeros []<span class="type">int</span>) {
    <span class="keyword">for</span> i := <span class="keyword">range</span> numeros {
        numeros[i] *= <span class="number">2</span>
    }
}

<span class="comment">// Para redimensionar, use ponteiro para slice</span>
<span class="keyword">func</span> <span class="function">adicionarElemento</span>(numeros *[]<span class="type">int</span>, valor <span class="type">int</span>) {
    *numeros = <span class="function">append</span>(*numeros, valor)
}

<span class="comment">// Ou retorne o slice modificado</span>
<span class="keyword">func</span> <span class="function">adicionarElemento2</span>(numeros []<span class="type">int</span>, valor <span class="type">int</span>) []<span class="type">int</span> {
    <span class="keyword">return</span> <span class="function">append</span>(numeros, valor)
}

<span class="keyword">func</span> <span class="function">main</span>() {
    nums := []<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}
    
    fmt.<span class="function">Println</span>(<span class="string">"Original:"</span>, nums)
    
    <span class="function">modificarElementos</span>(nums)
    fmt.<span class="function">Println</span>(<span class="string">"Modificado:"</span>, nums)
    
    <span class="function">adicionarElemento</span>(&nums, <span class="number">12</span>)
    fmt.<span class="function">Println</span>(<span class="string">"Com novo elemento:"</span>, nums)
    
    nums = <span class="function">adicionarElemento2</span>(nums, <span class="number">14</span>)
    fmt.<span class="function">Println</span>(<span class="string">"Outra forma:"</span>, nums)
}</code></pre>
            </div>
        </section>
        
        <section class="section">
            <h2>Comparação: Com e Sem Ponteiros</h2>
            
            <div class="comparison-grid">
                <div class="comparison-card">
                    <h4>Passagem por Valor</h4>
                    <ul class="list" style="margin-top: 15px;">
                        <li>Cria uma cópia</li>
                        <li>Seguro (imutável)</li>
                        <li>Bom para tipos pequenos</li>
                        <li>Sem efeitos colaterais</li>
                        <li>Mais simples de entender</li>
                    </ul>
                </div>
                
                <div class="comparison-card">
                    <h4>Passagem por Ponteiro</h4>
                    <ul class="list" style="margin-top: 15px;">
                        <li>Compartilha memória</li>
                        <li>Permite modificação</li>
                        <li>Eficiente para tipos grandes</li>
                        <li>Pode ter efeitos colaterais</li>
                        <li>Requer mais cuidado</li>
                    </ul>
                </div>
            </div>
        </section>
        
        <section class="section">
            <h2>Resumo e Boas Práticas</h2>
            
            <div class="highlight-box success">
                <h3 style="margin-bottom: 15px;">✅ Quando Usar Ponteiros</h3>
                <ul class="list">
                    <li>Quando precisar modificar o valor original em uma função</li>
                    <li>Para structs grandes (evitar cópias custosas)</li>
                    <li>Quando trabalhar com estruturas de dados recursivas (listas, árvores)</li>
                    <li>Para implementar métodos que modificam o receiver</li>
                    <li>Quando nil é um valor válido/significativo</li>
                    <li>Para compartilhar dados entre goroutines (com sincronização)</li>
                </ul>
            </div>
            
            <div class="highlight-box info">
                <h3 style="margin-bottom: 15px;">💡 Quando NÃO Usar Ponteiros</h3>
                <ul class="list">
                    <li>Para tipos primitivos pequenos (int, bool, float64)</li>
                    <li>Quando imutabilidade é importante</li>
                    <li>Para structs pequenas sem necessidade de modificação</li>
                    <li>Quando a cópia é intencional</li>
                    <li>Em funções puramente matemáticas/funcionais</li>
                </ul>
            </div>
            
            <div class="highlight-box warning">
                <h3 style="margin-bottom: 15px;">⚠️ Cuidados Importantes</h3>
                <ul class="list">
                    <li>Sempre verifique ponteiros nil antes de desreferenciar</li>
                    <li>Evite retornar ponteiros para variáveis locais em linguagens sem GC (em Go é seguro)</li>
                    <li>Cuidado com condições de corrida ao compartilhar ponteiros entre goroutines</li>
                    <li>Não compare ponteiros para verificar igualdade de valores</li>
                    <li>Seja consistente: se um método usa pointer receiver, todos devem usar</li>
                    <li>Documente quando uma função modifica seus argumentos</li>
                </ul>
            </div>
            
            <div class="highlight-box danger">
                <h3 style="margin-bottom: 15px;">🚫 Erros Comuns</h3>
                <ul class="list">
                    <li>Desreferenciar ponteiros nil (causa panic)</li>
                    <li>Esquecer & ao passar argumento que requer ponteiro</li>
                    <li>Esquecer * ao acessar valor do ponteiro</li>
                    <li>Confundir quando modificações são refletidas no original</li>
                    <li>Usar ponteiros desnecessariamente para tipos pequenos</li>
                    <li>Não inicializar ponteiros antes de usar</li>
                </ul>
            </div>
        </section>
        
        <section class="section">
            <h2>Exercícios Práticos</h2>
            
            <div class="highlight-box">
                <h3 style="margin-bottom: 15px;">🎯 Desafios</h3>
                
                <p><strong>1. Swap de Valores</strong></p>
                <p style="margin-bottom: 15px;">Crie uma função que troca os valores de duas variáveis usando ponteiros. Teste com diferentes tipos (int, string, struct).</p>
                
                <p><strong>2. Contador Compartilhado</strong></p>
                <p style="margin-bottom: 15px;">Crie uma struct Contador com métodos Incrementar, Decrementar e ObterValor. Use ponteiros para modificar o estado.</p>
                
                <p><strong>3. Lista Duplamente Encadeada</strong></p>
                <p style="margin-bottom: 15px;">Implemente uma lista duplamente encadeada onde cada nó tem ponteiros para o anterior e próximo.</p>
                
                <p><strong>4. Árvore Binária</strong></p>
                <p style="margin-bottom: 15px;">Crie uma estrutura de árvore binária usando ponteiros. Implemente inserção e busca.</p>
                
                <p><strong>5. Pool de Objetos</strong></p>
                <p style="margin-bottom: 15px;">Crie um pool que reutiliza objetos usando ponteiros para evitar alocações desnecessárias.</p>
                
                <p><strong>6. Modificador de Slices</strong></p>
                <p style="margin-bottom: 15px;">Crie funções que modificam slices: uma que modifica elementos e outra que adiciona elementos usando ponteiros.</p>
                
                <p><strong>7. Sistema de Configuração</strong></p>
                <p style="margin-bottom: 15px;">Crie uma struct Config com métodos que retornam ponteiros para permitir method chaining (builder pattern).</p>
                
                <p><strong>8. Comparador de Structs</strong></p>
                <p>Crie funções que comparam structs por valor e por referência. Demonstre a diferença.</p>
            </div>
        </section>
        
        <footer>
            <p>📚 Ponteiros são fundamentais em Go - pratique bastante!</p>
            <p>💡 Próximo tópico: Interfaces e Polimorfismo</p>
        </footer>
    </div>
</body>
</html>
